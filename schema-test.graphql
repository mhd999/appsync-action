schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

input OrderAdditionalProductData {
  productCode: String
  productAction: String
  productCharacteristics: [ProductCharacteristicsInput]
}

input ProductCharacteristicsInput {
  productCharacteristicCode: String
  productCharacteristicValue: [ProductCharacteristicValueInput]
}

input ProductCharacteristicValueInput {
  name: String
  value: String
}

enum OrderAdditionalProductAction {
  ADD
  DELETE
  USE
  MODIFY
}

type OrderAdditionalProductResponse {
  orderId: String
}

type DeferInvoicePayload {
  success: Boolean
  reason: String
  nextPaymentDate: AWSDate
  originalPaymentDate: AWSDate
}

input TransferOwnerInput {
  firstName: String!
  lastName: String!
  zipCode: String!
  ssn: String!
  email: String!
  transferredNumber: String!
  contactNumber: String!
  breakageFeeAccepted: Boolean!
}

type TransferOwnerPayload {
  orderId: String
}

type AccountUpdatePayload {
  orderId: String
}

type ProductUserUpdatePayload {
  orderId: String
}

input EmailOrderInput {
  orderNumber: String!
  orgName: String!
  orgNumber: String!
  selectedPhone: String!
  switchReplacement: SwitchReplacement!
  deliveryAddress: AddressInput!
  orderer: OrdererInput!
  deliveryMethod: String!
}

input OrdererInput {
  firstName: String!
  lastName: String!
  email: String!
  phone: String!
}

input SwitchReplacement {
  existingImei: String!
  caseNumber: String
  hasPlussInsurance: Boolean
  remainingDownpayment: Float
}

input AccountUpdateInput {
  accountId: String
  distributionCode: DistributionCode
  legalOwnerEmail: String
  invoiceReceiver: ICustomer
}

input ICustomer {
  name: NameInput!
  address: AddressInput
  emailAddress: String
  telephoneNumber: TelephoneNumberInput
}

input NameInput {
  firstName: String!
  lastName: String!
}

input AddressInput {
  postBoxNumber: String
  postBoxName: String
  postBoxLocation: String

  streetName: String
  streetNumber: String
  streetNumberSuffix: String
  floorNumber: String
  doorNumber: String
  coName: String

  city: String!
  zipCode: String!
  country: String
  attention: String
  locality: String
}

enum DistributionCode {
  EE
  RG
}

enum AccessLevel {
  Normal
  OTP
}

type OrderSimCardStatus {
  roleNotAccepted: Boolean!
  subscriptionSuspended: Boolean!
  orderAlreadyInProgress: Boolean!
}

enum PaymentActivityType {
  INVOICE
  CREDIT_NOTE
  PAYMENT
}

enum AgreementType {
  BUSINESS
  PRIVATE
}

type PaymentHistoryItem implements BalanceHistoryItem {
  amount: PriceType
  balance: PriceType
  type: PaymentActivityType
  date: AWSDate
  reference: String
}

type InvoiceHistoryItem implements BalanceHistoryItem {
  amount: PriceType
  balance: PriceType
  type: PaymentActivityType
  date: AWSDate
  reference: String
  invoice: Invoice!
}

interface BalanceHistoryItem {
  amount: PriceType
  balance: PriceType
  type: PaymentActivityType
  date: AWSDate
  reference: String
}

type CollectionAgency {
  code: String
  name: String
  caseNumber: String
}

input Paging {
  skip: Int!
  take: Int!
}

type OrderPage {
  hasNext: Boolean
  orders: [Order]
}

enum AccountType {
  Business,
  Exceptional,
  Chess,
  Individual,
  Major,
  Organization,
  Prepaid,
  ServiceProvider,
  Unknown
}

enum InvoiceDistribution {
  Mail,
  Email,
  EFaktura,
  Unknown
}

type AccountData {
  id: String!
  agreementType: AgreementType!
  accountType: AccountType!
  invoiceDistribution: InvoiceDistribution!
  invoices(startDate: AWSDate, skip: Int, take: Int): [Invoice!]
  currentInvoice: Invoice!
  invoice(id: String!): Invoice
  paymentBalance: PaymentBalance!
  paymentHistory(paging: Paging!): [BalanceHistoryItem!]
  collectionAgency: CollectionAgency
  orders(pageSize: Int = 11, pageNumber: Int = 0): OrderPage
  order(orderId: Int!): OrderDetail
  roles: [UserRole!]!
  xLinesInfo (detailed: Boolean): XLinesInfoResult
  subscription(phoneNumber: String!): SubscriptionData!
  subscriptions: [SubscriptionData!]
  invoiceReceiver: Customer
  legalOwner: Customer
}

type XLinesInfoResult {
  xLines: XLinesInfo
  subscriptions: [XLinesSubscription]
}

type XLinesInfo {
  count: Int
  pricePerPerson: Float
  totalPrice: Float
  subscriptions: [XLinesSubscription]
}

type XLinesSubscription {
  phoneNumber: PhoneNumber
  offeringName: String
  subscriptionType: String
  additionalOffering: String
  name: String
  price: String
  orderId: String
  disabled: Boolean
}

type PaymentBalance {
  amount: Float!
  unit: String
  customQuantity: String
  formatted: String
  dueDate: AWSDate
}

type Country {
  code: String!
  name: String!
}

type Invoice {
  invoiceNumber: String
  billingDate: AWSDate
  dueDate: AWSDate
  paid: Boolean
  period: InvoicePeriod
  paymentReference: String
  amount: PriceType
  invoiceGroup: [InvoiceGroup]
}

type InvoiceGroup {
  name: String
  totalAmount: PriceType
  invoiceRow: [InvoiceRow]
}

type InvoiceRow {
  name: String
  totalAmount: PriceType
}

type InvoicePeriod {
  startDate: AWSDate
  endDate: AWSDate
}

type InvoicedService {
  serviceName: String
  items: [InvoicedServiceUsage!]
  summary: InvoicedServiceSummary!
}

type InvoicedServiceSummary {
  quantity: Quantity
  duration: Quantity
  price: PriceType
}

type InvoicedServiceUsage {
  date: AWSDateTime
  destination: InvoicedServiceUsageDestination
  roamingOperator: String
  country: Country
  quantity: Quantity
  duration: Quantity
  price: PriceType
}

type InvoicedServiceUsageDestination {
  phoneNumber: PhoneNumber
  country: Country
}

type FooterLink {
  text: String!
  title: String
  href: String!
}

type PageFooter {
  links: [FooterLink!]
}

type PageHeader {
  logoAltText: String
}

type PageLayout {
  header: PageHeader!
  menu: PageMenu!
  footer: PageFooter!
}

type PageLink {
  href: String!
  text: String!
  iconSvg: String
  iconUrl: String
}

type PageMenu {
  searchUrl: String!
  sections: [PageMenuSection!]
}

type PageMenuSection {
  section: String!
  topContent: String
  upperLinks: [PageLink!]
  lowerLinks: [PageLink!]
}

type PhoneNumber {
  countryCode: String!
  localNumber: String!
}

input TelephoneNumberInput {
  countryCode: String!
  localNumber: String!
}

type PriceType {
  value: Float!
  currency: String
  formatted: String!
  valueWithVat: Float!
  valueWithoutVat: Float!
}

type Quantity {
  amount: Float!
  unit: String
  customQuantity: String
  formatted: String
}

type UrbanAddress {
  careOfName: String
  streetName: String
  streetNr: String
  streetNrSuffix: String
  city: String
  iso3CountryCode: String
  postcode: String
  floorNumber: String
  doorNumber: String
  direction: String
  locality: String
}

type PoboxAddress {
  boxNr: String
  boxName: String
  city: String
  iso3CountryCode: String
  postcode: String
}

type Address {
  urbanAddress: UrbanAddress
  poboxAddress: PoboxAddress
}

type ProductUser {
  title: String
  firstName: String
  surname: String
  emailAddress: String
  address: Address
  telephoneNumber: PhoneNumber
  ssnRegistered: Boolean
  roleIndicator: Boolean
  birthDate: AWSDate
}

type Organization {
  name: String
  organizationNumber: String
  emailAddress: String
  address: Address
  customerId: String
  sapId: String
}

type Customer {
  individual: ProductUser
  organization: Organization
}

type AdditionalProductPresentation {
  active: Boolean
  selected: Boolean
  modifiable: Boolean
  removed: Boolean
  included: Boolean
  preselected: Boolean
  changed: Boolean
}

enum AdditionalProductCategory {
  BARRING
  VAS
  SWITCH
  SERVICE
  DATA
  GIFT_DATA
}

enum AdditionalProductMainGroup {
  BARRING
  STREAMING
}

type AdditionalProduct {
  code: String
  productCategory: AdditionalProductCategory
  presentation: AdditionalProductPresentation
  weight: Int
  excludedAdditionalProducts: [String]
  name: String
  shortName: String
  descriptionLink: String
  shortDescription: String
  longDescription: String
  groups: [String]
  mainProductGroup: AdditionalProductMainGroup
  productGroup: String
  physicalProduct: String
  category: String
  contentService: String
  requireEmail: String
  smsOrderCode: String
  entitlement: String
  targetDevice: String
  twoStepProcessing: String
  switchStep: String
  mandatoryInstallment: String
  insuranceTerms: String
  flexibleSwitch: String
  characteristic: [ProductCharacteristicPM]
  price: AdditionalProductPricePM
  effectiveDate: AWSDate
  expirationDate: AWSDate
}

type AdditionalProductPricePM {
  price: Float
  priceAggregated: Float
  priceWithoutDiscount: Float
  discountDuration: Float
}

type ProductCharacteristicPM {
  featureCode: String
  config: [ProductCharacteristicConfigPM]
}

type ProductCharacteristicValidationRule {
  dataType: String
  minLength: Int
  maxLength: Int
  description: String
  ruleExpression: String
  sampleData: String
}

type ProductCharacteristicConfigPM {
  name: String
  defaultValue: String
  value: String
  description: String
  characteristicType: String
  mandatory: Boolean
  modifiable: Boolean
  displayable: Boolean
  availableForDelivery: String
  changeAllowedAfter: String
  possibleValues: [ProductCharacteristicConfigPossibleValuesPM]
  validationRule: ProductCharacteristicValidationRule
}

type ProductCharacteristicConfigPossibleValuesPM {
  value: String
  description: String
}

enum BillingType {
  Prepaid
  Postpaid
  Control
  Unknown
}

enum SubscriptionStatus {
  Active
  Suspended
  Reserved
  Cancelled
}

enum StatusReasonCode {
  Lost
  Stolen
  NotPaying
  DebtCollection
  Other
  AgencyAssign
  CustomerRequest
  Fraud
  OverCreditLimit
  SoftCollection
  UnderMaturityAge
}

type SpotifyActivation {
  isActivated: Boolean!
  authenticationUrl: String
  productNames: [String]
}

type TopupQuota {
  value: Int!
  unit: String!
  type: String!
}

enum TopupType {
  DOMESTIC
  ROAMING
  DATA_FREE,
  DATA_BOOST,
  DATA_BOOST_FREE
}

enum TopupPaymentType {
  INVOICE,
  VIPPS,
  VIPPS_NETS,
  TWO_PHASE_NETS
}

interface Topup {
  id: String!
  name: String!
  shortDescription: String!
  quota: TopupQuota,
  type: TopupType,
  weight: Int!,
}

type DomesticTopup implements Topup {
  id: String!
  name: String!
  shortDescription: String!
  price: PriceType,
  quota: TopupQuota,
  type: TopupType,
  weight: Int!,
  paymentType: [TopupPaymentType],
}

type RoamingTopup implements Topup {
  id: String!
  name: String!
  shortDescription: String!
  price: PriceType,
  quota: TopupQuota,
  type: TopupType,
  weight: Int!,
  paymentType: [TopupPaymentType],
}

type DataBoostTopup implements Topup {
  id: String!
  name: String!
  shortDescription: String!
  price: PriceType,
  quota: TopupQuota,
  type: TopupType,
  weight: Int!,
  paymentType: [TopupPaymentType],
}

type FreeDataTopup implements Topup {
  id: String!
  name: String!
  shortDescription: String!
  quota: TopupQuota,
  type: TopupType,
  weight: Int!,
  numberOfVouchers: Int!
  latestReceivedDate: AWSDate!
  nextExpirationDate: AWSDate!
}

type FreeDataBoostTopup implements Topup {
  id: String!
  name: String!
  shortDescription: String!
  quota: TopupQuota,
  type: TopupType,
  weight: Int!,
  numberOfVouchers: Int!
  latestReceivedDate: AWSDate!
  nextExpirationDate: AWSDate!
}

enum TopupFilterRoamingZone {
  "Automatic zone detection"
  AUTODETECT

  "Use the countryCode input field to specify ISO2 code of the country you want topups for"
  FROM_COUNTRY_CODE

  EU
  USA
  ZONE1
  ZONE2
  ZONE3
  ZONE4

  "Offshore"
  OS
}

input TopupFilter {
  zone: TopupFilterRoamingZone

  "ISO2 country code format. Use this field together with zone = FROM_COUNTRY_CODE"
  countryCode: String
}

type SubscriptionData {
  communicationPreferences: [CommunicationPreferencesResponse]
  phoneNumber: PhoneNumber!
  invoices(startDate: AWSDate, skip: Int, take: Int): [Invoice!]
  currentInvoice: Invoice
  invoice(id: String!): Invoice
  invoicedService(invoiceId: String!, serviceCodes: [String!]!): InvoicedService
  unbilledService(serviceCodes: [String!]!): InvoicedService
  userOffering(phoneNumber: String): UserOffering
  newOfferingDetails(
    phoneNumber: String
    offering: String
    includeBtlOffers: Boolean
    products: [String]
  ): NewOfferingDetails
  orderSimCardStatus: OrderSimCardStatus!
  usage(phoneNumber: String): [Usage]
  callForwarding: CallForwardGetResponse
  paymentBalance: Quantity!
  billingType: BillingType!
  orders(pageSize: Int = 11, pageNumber: Int = 0): OrderPage
  order(orderId: Int!): OrderDetail
  invoiceType: String!
  invoiceTypeParameter: String
  invoiceReceiver: Customer
  legalOwner: Customer
  publishLevelCode: String
  productUser: ProductUser
  agreementType: AgreementType
  subscriptionStatus: SubscriptionStatus
  subscriptionStatusDate: AWSDate
  commitmentStartDate: AWSDate
  commitmentEndDate: AWSDate
  statusReasonCode: StatusReasonCode
  canBeSuspended: Boolean!
  canBeUnSuspended: Boolean!
  additionalProducts(
    productCategory:  AdditionalProductCategory
    mainProductGroup: AdditionalProductMainGroup,
    manualProduct: String #Deprecated in favour of manualProducts
    manualProducts: [String!]): [AdditionalProduct!]
  spotifyActivation(redirectUrl: String!): SpotifyActivation
  mainSimcard: MainSimCard
  additionalSimcards: [AdditionalSimCard]
  roles: [UserRole!]!
  topups(filter: TopupFilter): [Topup!]!
}

type MainSimCard {
  simCardNumber: String
  pukCode: String
  pukCode2: String
  initialPin: String
  initialPin2: String
  imsi: String
  formFactor: String
  isEsim: Boolean
  type: String
}

type AdditionalSimCard {
  simCardNumber: String
  pukCode: String
  pukCode2: String
  initialPin: String
  initialPin2: String
  imsi: String
  formFactor: String
  isEsim: Boolean
  type: String
  product: AdditionalProduct
}

type DirectoryListing {
  id: Int
  key: String
  shortDescription: String
  longDescription: String
  brand: String
  channel: String
}

enum UserRole {
  NETCOM_MOBILE_USERS
  NETCOM_MOBILE_USERS_SUSPENDED
  NETCOM_MOBILE_USERS_OTHER
  NETCOM_KS_CONSULTANT_PERSON_CUSTOMER
  NETCOM_KS_SUPERVISOR_PERSON_CUSTOMER
  NETCOM_IT_OPERATIONS_CONSULTANT
  APPLICATION_GROUP_PREFIX
  COMPANY
  COMPANY_ADMINISTRATOR
  COMPANY_REPORT_USER
  ACCOUNT_ADMINISTRATOR
  ACCOUNT_SUPERVISOR
  ACCOUNT_REPORT_USER
  GROUP_ADMINISTRATOR
  GROUP_SUPERVISOR
  GROUP_REPORT_USER
  PROBIZ_END_USER
  PROBIZ_INTERCEPTION_USER
  PROBIZ_SWAT_USER
  CS_CONSULTANT_JUKEBOX
  WO_END_USER
  WO_INTERCEPTION_USER
  WO_SWAT_USER
  WO_STATISTICS_END_USER
  WO_END_USER_INACTIVE
  MO_END_USER
  OPEN_API_END_USER
  OPEN_API_ADMIN
  VEIVISER
  WEB_EDITOR
  KEY_ACCOUNT_MANAGER
  CUSTOMER_SERVICE
  CUSTOMER_CARE
  NETCOM_ADMIN
  FN_ADMIN
  SECOND_LINE_SUPPORT
  MARKETING_RESPONSIBLES
  AGREEMENT_ADMINISTRATORS
  DEALER_CONSULTANTS
  DEALERS
  DEALERS_DK
  CHAIN_REPRESENTATIVE
  NETCOM_CGI_SUPPORT
  LEGAL_OWNER
  INVOICE_PAYER
  PRODUCT_USER
  TF_ADMINISTRATOR
  TF_MEMBER_OF_AGE
  USER_OF_AGE
  UNKNOWN
  ACCOUNT_ADMIN_PRIVATE
  ACCOUNTOWNERPRIVATE
  SUBSENDUSERPRIVATE
  WEAKLY_AUTHENTICATED
  CUSTOMER_OPERATIONS
}

enum InvoicePaymentStatus {
  None
  Initialized
  Reserved
  Delivered
}

type UserData {
  id: ID!
  phoneNumber: PhoneNumber!
  isAccountOwner: Boolean! @deprecated(reason: "Use the roles array instead.")
  isBusiness: Boolean!
  accessLevel: AccessLevel!
  hasRecentlyPaidInvoice: Boolean! @deprecated(reason: "Has been replaced with invoiceCardPaymentStatus.")
  invoiceCardPaymentStatus: InvoicePaymentStatus!
  roles: [UserRole!] @deprecated(reason: "User roles have been split into subscription and account roles. Use the roles field in either of those objects")
}

type Query {
  layout(loggedIn: Boolean!, userContext: LayoutUserContext): PageLayout!
  subscription(phoneNumber: String): SubscriptionData!
  subscriptions: [SubscriptionData!]
  account(accountId: String): AccountData!
  accounts: [AccountData!]
  user: UserData
  nbaOffer(userId: String!, userName: String): UserOffer
  offer(userID: String!, userName: String, uToken: String, ctSession: String, dataType: String): UserOffer @deprecated(reason: "Use `nbaOffer`.")
  credit(organizationNumber: Int!): CreditCheck
  productsAvailability(skus: [Int!]): [ProductAvailability]
  directoryListings: [DirectoryListing]
  webdeal(cart: Cart!): [WebdealFormat]
  longQuery(userId: String!): LongQueryResult
  geographicSites(offset: Int, limit: Int): [GeographicSite!]!
  geographicSite(id: ID!): GeographicSite
  countries: [RoamingCountry]
}

type Subscription {
  onlongQueryResult(id: ID!): [LongQueryResult]
    @aws_subscribe(mutations: ["publishLongQueryResult"])
  onOrderStatusUpdate(id: ID!): OrderStatus!
    @aws_subscribe(mutations: ["publishOrderStatusUpdate"])
}


enum LayoutUserContext {
  B2B
  B2C
}

enum PaymentProvider {
  NETS
  PAYEX
}

input PayInvoiceBalanceInput {
  returnUrl: String!
  cancelUrl: String
  clientIp: String
  provider: PaymentProvider
  accountId: String
}

type PayInvoiceBalanceOutput {
  redirectUrl: String!
}

enum ConfirmInvoicePaymentStatus {
  OK
  FAILED
}

type ConfirmInvoicePaymentOutput {
  result: ConfirmInvoicePaymentStatus!
}

enum AdditionalTokenType {
  MobileAppFirebase
}

type IdentityToken {
  returnUrl: String
  token: String
  phoneNumber: PhoneNumber
  additionalToken(type: AdditionalTokenType!): String
}

enum IdentityLoginScope {
  OpenId
  OpenIdWithOfflineAccess
}

enum IdentityLoginPrompt {
  None
  Login
}


enum IdentityAuthorizationLevel {
  Basic
  TwoFactor
  BankId
}

type SubmitOfferingOrderPayload {
  orderId: String!
}

type CreateOfferingOrderPayload {
  orderId: String!
  teliaXPrice: String
  teliaXOfferingName: String
}

input ChangeOfferingSubscription {
  offering: String
  phoneNumber: TelephoneNumberInput
}

type Mutation {
  orderAdditionalProduct(
    phoneNumber: String
    additionalProducts: [OrderAdditionalProductData]
    email: String
  ): OrderAdditionalProductResponse
  payInvoiceBalance(input: PayInvoiceBalanceInput): PayInvoiceBalanceOutput
  confirmInvoicePayment(purchaseId: String!, provider: PaymentProvider): ConfirmInvoicePaymentOutput
  transferOwner(input: TransferOwnerInput!): TransferOwnerPayload
  accountUpdate(input: AccountUpdateInput!): AccountUpdatePayload
  productUserUpdate(phoneNumber: String, productUser: ICustomer!): ProductUserUpdatePayload
  deferInvoice: DeferInvoicePayload
  updateCallForwarding(phoneNumber: String, settings: CallForwardPutInput): CallForwardPutResponse
  updateCommunicationPreferences(
    phoneNumber: String
    settings: [UpdateCommunicationPreferencesInput]
  ): UpdateCommunicationPreferencesResponse
  updateDirectoryListing(phoneNumber: String, directoryListingLevel: String): UpdateCommunicationPreferencesResponse
  generateIdentityLoginUrl(redirectUrl: String!, tokenUrl: String, scope: IdentityLoginScope, prompt: IdentityLoginPrompt, authLevel: IdentityAuthorizationLevel): String
  generateIdentityLogoutUrl(redirectUrl: String!): String
  createIdentityToken(state: String!, code: String!): IdentityToken
  refreshIdentityToken: IdentityToken
  changeSubscriptionStatus(phoneNumber: String, status: SubscriptionStatusChange): changeSubscriptionStatusPayload
  changeOffering(phoneNumber: String, offering: String!, products: [String], campaignId: String): changeOfferingPayload
  nbaPostOfferInteraction(interactionUrl: String!, userName: String): interactionsResponse
  postOfferInteraction(interactionURL: String!, userName: String, uToken: String, ctSession: String): interactionsResponse  @deprecated(reason: "Use `nbaPostOfferInteraction`.")
  spotifyActivationUpdate(phoneNumber: String!, redirectUrl: String!, code: String!): String!
  emailOrder(input: EmailOrderInput!): String!
  publishLongQueryResult(result: LongQueryInput): LongQueryResult
  createOfferingOrder(subscriptions: [ChangeOfferingSubscription]): CreateOfferingOrderPayload
  submitOfferingOrder(orderId: String): SubmitOfferingOrderPayload
  publishOrderStatusUpdate(result: OrderStatusUpdateInput): OrderStatus
  generateAdditionalToken(type: AdditionalTokenType!): String
}

type OrderStatus {
  id: ID!
  state: String!
  lastModified: AWSDateTime!
}

input OrderStatusUpdateInput {
  id: ID!
  state: String!
  lastModified: AWSDateTime!
}


type OfferButtonText {
  accept: String!
  reject: String!
}

type OfferCommitment {
  commitmentStartDate: String
  commitmentEndDate: String
  monthsLeft: Int
}

type OfferActivityDetails {
    componentType: String
    currentOffering: String
    recommendedProduct: String
    title: String
    text: String
    groupTemplate: String
    buttonText: OfferButtonText
    commitment: OfferCommitment
    buttonUrl: String
}

type OfferInteractions {
  view: String!
  click: String!
  reject: String!
  later: String!
  accept: String!
}

type OfferNba {
  title: String
  description: String
  commitment: String
  currentOffering: OfferCurrentOffering
  recommendedOffering: OfferRecommendedOffering
  redirectUrl: String
}

type OfferCurrentOffering {
  data: Float
  unit: String
  name: String
  longName: String
  price: Float
  monthlyPrice: Float
  yearlyPrice: Float
  discountPercentage: Float
  discountPrice: Float
  totalData: Float
  extraData: Float
  disclaimerText: String
}

type OfferRecommendedOffering {
  data: Float
  unit: String
  name: String
  longName: String
  price: Float
  monthlyPrice: Float
  yearlyPrice: Float
  discountPercentage: Float
  discountPrice: Float
  totalData: Float
  extraData: Float
  disclaimerText: String
}

type UserOffer {
  activityProductType: String
  activitySubType: String
  activityName: String
  activityDetails: OfferActivityDetails
  interactions: OfferInteractions
  nba: OfferNba
}

type CallForwardGetResponse {
  callForwardUnconditional: CallForward
  callForwardWhenBusy: CallForward
  callForwardWhenNoReply: CallForward
  callForwardWhenNotReachable: CallForward
}

type CommunicationPreferencesResponse {
  communicationChannel: String
  value: Boolean
  description: String
  brand: String
}

type CallForward {
  active: Boolean
  number: String
}

type BusinessAddress {
  postCode: String
  city: String
  streetName: String
  streetNumber: String
}

type PostBoxAddress {
  postBoxNumber: String
  postCode: String
  city: String
}

type PostalAddress {
  postBoxAddress: PostBoxAddress
}

type CreditCheck {
  success: Boolean
  organizationNumber: Int
  name: String
  decision: String
  score: Int
  externalDecision: String
  internalDecision: String
  creditLimit: Int
  logReference: Int
  businessAddress: BusinessAddress
  postalAddress: PostalAddress
}

type ProductAvailability {
  productCode: String
  dcQtyAvailable: Int
}

input CallForwardPutInput {
  callForwardUnconditional: CallForwardInput
  callForwardWhenBusy: CallForwardInput
  callForwardWhenNoReply: CallForwardInput
  callForwardWhenNotReachable: CallForwardInput
}

input UpdateCommunicationPreferencesInput {
  communicationChannel: String
  value: Boolean
}

input CallForwardInput {
  active: Boolean
  number: String
}

type CallForwardPutResponse {
  orderId: String
}

type UserOffering {
  pricePlan: String
  name: String
  shortName: String
  descriptionLink: String
  shortDescription: String
  longDescription: String
  additionalProperties: [AdditionalProperty]
  disclaimers: [Disclaimer]
  offeringPrices: [OfferingPrice]
  commitmentTimeInMonths: Int
}

type Offering {
  name: String
  pricePlan: String
  telephoneNumberCategory: String
  requiresCreditWorthiness: Boolean
  preconfigurable: Boolean
  commitmentTimeInMonths: Int
  requiresHardwareBundle: Boolean
  requiresBreakageFee: Boolean
  requiresSimReplacement: Boolean
  additionalProperties: [AdditionalProperty]
  shortName: String
  shortDescription: String
  longDescription: String
  price: OfferingPrice
  disclaimers: [Disclaimer]
  weight: Int
  lifecycleStatus: String
}

type NewOfferingDetails {
  offering: Offering
  offerings: [Offering]
  lostProducts: [ProductService]
  addedProducts: [ProductService]
  activeProducts: [ProductService]
  invalidProducts: [String]
}

type ProductService {
  additionalProperties: [AdditionalProperty]
  availableForPaymentType: [String]
  code: String
  commitmentEndDate: String
  commitmentLength: Int
  commitmentStartDate: String
  descriptionLink: String
  disclaimers: [Disclaimer]
  effectiveDate: String
  excludedAdditionalProducts: [String]
  expirationDate: String
  groups: [String]
  longDescription: String
  name: String
  productCategory: String
  presentation: ProductServicePresentation
  characteristics: PmProductServiceCharacteristic
  requiresOneOfAdditionalProducts: [String]
  shortDescription: String
  shortName: String
  status: String
  weight: Int
  active: Boolean
  price: ProductServicePrice
}

type PmProductServiceCharacteristic {
  featureCode: String
  config: [PmProductServiceCharacteristicValue]
}

type PmProductServiceCharacteristicValue {
  name: String
  defaultValue: String
  value: String
  description: String
  characteristicType: String
  mandatory: Boolean
  modifiable: Boolean
  displayable: Boolean
  availableForDelivery: String
}

type ProductServicePresentation {
  active: Boolean
  included: Boolean
  modifiable: Boolean
  preselected: Boolean
  removed: Boolean
  selected: Boolean
}

type ProductServicePrice {
  price: Float
  priceAggregated: Float
  priceWithoutDiscount: Float
  discountDuration: Float
}

input ProductServiceOrderData {
  productCode: String
  productAction: String
  productCharacteristics: ProductServiceCharacteristic
}

input ProductServiceCharacteristic {
  productCharacteristicCode: String
  values: [ProductServiceCharacteristicValue]
}

input ProductServiceCharacteristicValue {
  name: String
  value: String
}

enum ProductAction {
  ADD
  DELETE
  USE
  MODIFY
}

type ProductServiceOrderResponse {
  orderId: String
}

type AdditionalProperty {
  name: String
  value: String
}

type Disclaimer {
  code: String
  name: String
  weight: Float
  text: String
}

type OfferingPrice {
  offeringPrices: [OfferingPriceDetails]
  additionalProductPrices: [AdditionalProductPrice]
}

type OfferingPriceDetails {
  code: String
  description: String
  amount: Float
  monetaryUnit: String
  amountWithoutVat: Float
}

type AdditionalProductPrice {
  productCode: String
  price: [Price]
}

type Price {
  code: String
  description: String
  amount: Float
  monetaryUnit: String
}

type Usage {
  unit: String
  expireDate: AWSDate
  allowanceType: String
  category: String
  quotaId: String
  network: String
  type: String
  limit: Quantity
  remaining: Quantity
  used: Quantity
  description: String
}

type UpdateCommunicationPreferencesResponse {
  orderId: String
}

type Order {
  orderId: Int
  creationDate: AWSDateTime
  subscriptions: String
}

enum OrderType {
  TOPUP
  ACCOUNT_CONTACT
  SUBS_CONTACT
  SUBS_BLOCK
  SUBS_UNBLOCK
  ORDER
  SUBS_CHANGE_SERVICE
  SUBS_CHANGE_PRICEPLAN
  SUBS_CHANGE_SIM
}

type OrderPerson {
  firstName: String
  lastName: String
  birthDate: AWSDateTime
  emailAddress: String
}

enum OrderAddressType {
  URBAN
  POBOX
}

type OrderAddress {
  addressType: OrderAddressType
  boxName: String
  boxNr: String
  boxLocation: String
  city: String
  direction: String
  doorNumber: String
  floorNumber: String
  iso3countryCode: String
  postcode: String
  streetName: String
  streetNr: String
  streetNrSuffix: String
  careOfName: String
  locality: String
}

enum OrderItemType {
  NEW
  PORTING
  CHANGE
  FIXED_LINE_PORTING
  MODIFY_CALL_FORWARDING
  UNKNOWN
}

type MonetaryAmount {
  amountVAT: Float
  amountWithoutVAT: Float
  amountWithVAT: Float
  currency: String
  percentage: Int
}

enum PaymentType {
  EXTERNAL
  INTERNAL
  CLIENT
  BY_2PHASE_CHARGE
  PAYMENT_HANDLER
}

type HardwarePayment {
  upFrontPayment: MonetaryAmount
  totalPayment: MonetaryAmount
  downPayment: MonetaryAmount
  installment: MonetaryAmount
  lastInstallment: MonetaryAmount
  paymentType: PaymentType
  downPaymentType: String
  creditProvider: String
  numberOfInstallments: Int
}

type HardwareItem {
  equipmentName: String
  equipmentType: String
  price: MonetaryAmount
  materialId: String
  totalQuantity: Int
  toDeliverQuantity: Int
  simProductNumber: String
  creditAgreement: String
  deliveryStatus: String
  serialNumbers: [String]
  shippingConfirmedDate: AWSDateTime
  trackingNumber: String
  trackingUrl: String
}

type Person {
  firstName: String
  lastName: String
  birthDate: AWSDateTime
  emailAddress: String
}

type PortingDetails {
  simNumber: String
  epoaBtcAllowed: Boolean
  epoaBtbAllowed: Boolean
  operatorName: String
  estimatedPortingDate: AWSDateTime
  requestedPortingDate: AWSDateTime
  ordererContactNumber: OrderDetailPhoneNumber
  previousOwner: Person
  previousOwnerAddress: Address
  previousOwnerTelephone: OrderDetailPhoneNumber
}

type ProductCharacteristicValue {
  name: String
  value: String
  defaultValue: String
  description: String
  characteristicType: String
  mandatory: Boolean
  enabled: Boolean
  originalValue: String
  maxLength: Int
  ruleExpression: String
  modifiable: Boolean
  displayable: Boolean
}

type ProductCharacteristic {
  code: String
  featureCode: String
  values: [ProductCharacteristicValue]
}

type Product {
  code: String
  name: String
  active: Boolean
  selected: Boolean
  modifiable: Boolean
  removed: Boolean
  included: Boolean
  preselected: Boolean
  spotify: Boolean
  excluded: [String]
  requires: [String]
  group: [String]
  requiresConfiguration: Boolean
  productCharacteristics: [ProductCharacteristic]
  productSpecificationId: String
  category: String
  weight: Int
  effectiveDate: AWSDateTime
  expirationDate: AWSDateTime
  commitmentStartDate: AWSDateTime
  commitmentEndDate: AWSDateTime
  commitmentLength: Int
  action: String
  target: String
  checkedByDefault: Boolean
  checked: Boolean
  enabled: Boolean
  characteristicsEnabled: Boolean
  toBuy: Boolean
  requiresEmail: Boolean
  disclaimers: [Disclaimer]
}

type DirectoryListingLevelType {
  directoryListingLevel: String
  description: String
}

type CommunicationLevelType {
  communicationLevel: String
  description: String
}

type OrderSubscriptionItem {
  status: String
  offeringCode: String
  offeringName: String
  commitmentTimeInMonths: Int
  telephoneNumber: OrderDetailPhoneNumber
  temporaryTelephoneNumber: OrderDetailPhoneNumber
  type: OrderItemType
  hardwarePayment: HardwarePayment
  hardwareItems: [HardwareItem]
  portingDetails: PortingDetails
  activationFeeAmount: Int
  activationFeeCurrency: String
  simNumber: String
  imei: String
  communicationLevel: CommunicationLevelType
  directoryListingLevel: DirectoryListingLevelType
  productUser: OrderPerson
  productUserAddress: OrderAddress
  productUserTelephone: OrderDetailPhoneNumber
  additionalProducts: [Product]
  statusChange: String
}

type PaymentMethod {
  name: String
  bankAccountNumber: String
  bankCode: String
  bankBranchCode: String
}

type OrderInvoiceType {
  invoiceCode: String
}

type OrderAccountItem {
  status: String
  invoiceReceiver: OrderPerson
  invoiceReceiverAddress: OrderAddress
  invoiceReceiverTelephone: OrderDetailPhoneNumber
  invoiceType: OrderInvoiceType
  legalResponsibleEmail: String
  legalResponsibleTelephone: OrderDetailPhoneNumber
  paymentMethod: PaymentMethod
  communicationLevel: CommunicationLevelType
  accountId: String
}

type OrderDetailPhoneNumber {
  countryCode: String
  localNumber: String
  fullNumber: String
}

type Communication {
  subject: String
}

type OrderDetail {
  orderId: Int
  orderGuid: String
  orderType: OrderType
  orderState: String
  creationDate: AWSDateTime
  lastModifiedDate: AWSDateTime
  customerName: String
  phoneNumber: PhoneNumber
  telephoneNumbers: [String]
  subscriptions: String
  orderer: OrderPerson
  address: OrderAddress
  orderTermsApproved: Boolean
  subscriptionItems: [OrderSubscriptionItem]
  accountItems: [OrderAccountItem]
  emailNotificationRecipient: String
  nationalIdentificationNumber: String
  organizationNumber: Int
  organizationName: String
  dealerCode: String
  channelType: String
  business: Boolean
  signatureHolder: OrderPerson
  hasDocuments: Boolean
  communications: [Communication]
}

enum SubscriptionStatusInput {
  SUSPEND
  UNSUSPEND
}

input SubscriptionStatusChange {
  status: SubscriptionStatusInput
  reason: String
}

type changeSubscriptionStatusPayload {
  orderId: String
}

type changeOfferingPayload {
  orderId: String
}

type interactionsResponse {
  message: String
}

input Cart {
  dealerCode: String!
  channelType: String!
  mainHardwareSku: String
  skus: [String!]!
  agreementCode: String!
  campaignCombination: String
  switchPlan: String
  pricePlan: String
  freeProductCount: Int
  freeItemsCount: Int
}

type IImage {
  width: Int
  height: Int
}

type IDetails {
  size: Int
  image: IImage
}

type IFile {
  url: String
  details: IDetails
  fileName: String
  contentType: String
}

type IMainImage {
  title: String
  file: IFile
}

type IHandsetVariants {
  name: String
  sku: String
  mainImage: IMainImage
  b2bImage: IMainImage
  images: [IMainImage]
}

type IHandsets {
  name: String
  guid: String
  memory: String
  handsetVariants: [IHandsetVariants]
}

type ApplicableHandsets {
  name: String
  handsets: [IHandsets]
}

type IPrices {
  taxIncludedAmount: Float
  dutyFreeAmount: Float
  currencyCode: String
}

type IPriceInfo {
  productOfferingId: String
  instanceId: String
  price: IPrices
}

type ITypes {
  type: String
}

type IDiscountInfo {
  typename: String
  code: String
  applicableProducts: [String]
  campaignCombinations: [ITypes]
  freeProducts: [String]
  freeProductsCount: Int
  freeProductPercentageDiscount: Float
}

type IImageGallery {
  title: String
  file: IFile
}

type IAccessoryVariant {
  brand: String
  name: String
  sku: String
  originalPrice: IPrices
  discountedPrice: Float
  mainImage: IMainImage
  imageGallery: [IImageGallery]
  htmlColor: String
}

type ApplicableAccessories {
  name: String
  accessoryVariants: [IAccessoryVariant]
}

type DiscountInfo {
  typename: String
  code: String
  applicableProducts: [String]
  campaignCombinations: [ITypes]
  freeProducts: String
  freeProductCount: Float
  freeProductPercentageDiscount: Float
}

type WebdealFormat {
  webdealName: String
  webdealCode: String
  webdealType: String
  uniqueId: Int
  webdealDesc: String
  applicableHardware: [IAccessoryVariant]
}

enum ResultStatus {
  PENDING
  COMPLETE
  ERROR
}

type Operator {
  name: String
  mcc: String
  mnc: String
}

type RoamingCountry {
  name: String
  countryCode: String
  operators: [Operator]
  prefix: String
  countryPrice_invariant: Boolean
}



# The longQuery schema is just an example of how long query schema might look like.

type LongQueryResult {
  id: ID!
  status: ResultStatus!
  results: [String]
}

input LongQueryInput {
  id: ID!
  status: ResultStatus!
  results: [String]!
}

interface GeographicSite {
  id: ID!
  name: String
  status: String
  description: String
  address: GeographicAddress!
  calendar: [CalendarPeriod!]!
}

type CalendarPeriod {
  status: String
  day: String
  hourPeriod: [HourPeriod!]!
}

type HourPeriod {
  startHour: String
  endHour: String
}

type StoreGeographicSite implements GeographicSite {
  id: ID!
  name: String
  status: String
  description: String
  address: GeographicAddress!
  calendar: [CalendarPeriod!]!
  type: String
  phoneNumber: PhoneNumber
  email: String
  contacts: [StoreGeographicSiteContact!]
}

type StoreGeographicSiteContact {
  position: String
  name: String
  phoneNumber: PhoneNumber
  email: String
}

type GeographicAddress {
  streetNr: String
  streetName: String
  streetType: String
  streetSuffix: String
  postcode: String
  locality: String
  city: String
  stateOrProvince: String
  country: String
  geographicLocation: GeographicLocation
}

type GeographicLocation {
  geometryType: String
  accuracy: String
  spatialRef: String
  geometry: [GeographicPoint]
}

type GeographicPoint {
  x: String
  y: String
}
